---
title: 关键渲染路径（Critical Rendering Path)
---

# 关键渲染路径（Critical Rendering Path)

> DOM-> CSSOM -> RenderTree -> Layout -> Paint

## 构建 DOM

> Bytes -> Characters -> Tokens -> Dom

- 转换：浏览器从磁盘或网络读取 HTML 的原始字节，并根据文件的指定编码（例如 UTF-8）将它们转换成字符
- Token 化：将字符串转换成 Token，例如：html、body 等。Token 中会标识出当前 Token 是“开始标签”或是“结束标签”亦或是“文本”等

## 构建 CSSOM

> Bytes -> Characters -> Tokens -> Nodes -> CSSOM

- HTML 可以逐步解析，它不需要等待所有 DOM 都构建完毕后再去构建 CSSOM，而是在解析 HTML 构建 DOM 时，若遇见 CSS 会立刻构建 CSSOM，它们可以同时进行。
- CSS 不行，不完整的 CSS 是无法使用的，因为 CSS 的每个属性都可以改变 CSSOM，所以会存在这样一个问题：假设前面几个字节的 CSS 将字体大小设置为 16px，后面又将字体大小设置为 14px，那么如果不把整个 CSSOM 构建完整，最终得到的 CSSOM 其实是不准确的。所以必须等 CSSOM 构建完毕才能进入到下一个阶段，哪怕 DOM 已经构建完，它也得等 CSSOM，然后才能进入下一个阶段。

> 所以，CSS 的加载速度与构建 CSSOM 的速度将直接影响首屏渲染速度，因此在默认情况下 CSS 被视为阻塞渲染的资源。

## 构建渲染树 RenderTree

- 从 DOM 树的根节点开始遍历每个可见节点。
- 有些节点不可见（例如脚本 Token、元 Token 等），因为它们不会体现在渲染输出中，所以会被忽略。
- 某些节点被 CSS 隐藏，因此在渲染树中也会被忽略。例如：上图中的 p > span 节点就不会出现在渲染树中，因为该节点上设置了 display: none 属性。
- 对于每个可见节点，为其找到适配的 CSSOM 规则并应用它们。

## Layout

> 这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。

布局流程的输出是一个“盒模型”，它会精确地捕获每个元素在视口内的确切位置和尺寸，所有相对测量值都将转换为屏幕上的绝对像素。

## Paint 绘制

布局完成后，浏览器会立即发出“Paint Setup”和“Paint”事件，将渲染树转换成屏幕上的像素

## JS 与关键渲染路径

- 通常情况下 DOM 和 CSSOM 是并行构建的，但是当浏览器遇到一个 script 标签时，DOM 构建将暂停，直至脚本完成执行。
- 由于 JavaScript 可以修改 CSSOM，所以需要等 CSSOM 构建完毕后再执行 JS。

> 这是因为 JavaScript 不只是可以改 DOM，它还可以更改样式，也就是它可以更改 CSSOM。 不完整的 CSSOM 是无法使用的，但 JavaScript 中想访问 CSSOM 并更改它，那么在执行 JavaScript 时，必须要能拿到完整的 CSSOM。所以就导致了一个现象，如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟脚本执行和 DOM 构建，直至其完成 CSSOM 的下载和构建。

也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后在继续构建 DOM。
